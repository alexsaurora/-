#### 1.JavaScript规定了几种语言类型
  string;number;boolean;undefined;null;object;symbol 七种



#### 2.JavaScript对象的底层数据结构是什么

  堆和栈；引用类型的数据的地址指针存储于栈中，当我们想要访问引用类型的值时，需要先从栈中获得对象的地址指针，再通过地址指针找到堆中所需要的数据。



#### 3.Symbol类型在实际开发中的应用、可手动实现一个简单的 Symbol

symbol类型是es6中新加入的一种原始类型，每个从symbol（）返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的。

特点：1)，独一无二； 2）原始类型，使用Symbol（）函数创建symbol变量，并非使用构造函数，使用new操作符会直接报错； 3）不可枚举，使用Symbol作为对象属性时，可以保证对象不会出现重名属性，调用for...in不能枚举出来，另外调用Object.getOwnPropertyNames、Object.keys()也不能获得symbol属性，获取symbol属性有专门的方法：Object.getOwnPropertySymbols()。

应用：

* 私有属性

  借助Symbol类型的不可枚举，可以在类中模拟私有属性，控制变量读写

* 防止属性污染

  我们为对象添加一个属性时，可能会造成属性覆盖，用Symbol作为对象属性可以保证永远不会出现同名属性，不会造成属性污染

  

#### 4.JavaScript中的变量在内存中的具体存储形式

值类型变量，包括string;number;boolean;undefined;null;symbol 6种类型的值都存储在栈中；

object引用类型，它的值存储在堆内存中，在栈中只存储了一段指向堆内存值的地址指针。

#### 5.基本类型对应的内置对象，以及他们之间的装箱拆箱操作

string ——String

number——Number

boolean ——Boolean

包装类型也是对象，它与引用类型的主要区别在于对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前一直都保存在内存中；而基本类型只存在于一行代码的执行瞬间，然后立刻被销毁，这意味着我们不能在运行时为基本类型添加属性和方法。

装箱操作：把基本类型转换为对应的包装类型；

拆箱操作：把引用类型转换为基本类型。

我们使用基本类型调用方法，就会自动进行装箱和拆箱操作，相同的，我们使用`Number`和`Boolean`类型时，也会发生这个过程。

- 引用类型转换为`Number`类型，先调用`valueOf`，再调用`toString`
- 引用类型转换为`String`类型，先调用`toString`，再调用`valueOf`
- 若`valueOf`和`toString`都不存在，或者没有返回基本类型，则抛出`TypeError`异常。

#### 6.理解值类型和引用类型

值类型，代表值本身是不可被改变的。

栈内存：

- 存储的值大小固定
- 空间较小
- 可以直接操作其保存的变量，运行效率高
- 由系统自动分配存储空间

JavaScript中值类型的值被直接存储在栈中。在变量定义时，栈就为其分配好了内存空间，由于栈中内存空间的大小是固定的，那么注定了存储在栈中的变量就是不可变的。

引用类型的值可以改变。

堆内存：

- 存储的值大小不定，可动态调整
- 空间较大，运行效率低
- 无法直接操作其内部存储，使用引用地址读取
- 通过代码进行分配空间

引用类型的值存储在堆内存中，它在栈中只存储了一个固定长度的地址，这个地址指向堆内存中的值。

在进行复制操作时，值类型在内存中创建了一块新的空间去存储新变量的值，虽然两个变量的值是相等的，但二者指向的内存空间完全不同，两个变量参与任何操作都互不影响；复制引用类型的变量时，实际复制的是栈中存储的地址，所以复制出来的变量和原变量指向的是堆中的同一个对象，因此，改变任意一个变量的值，另一个都会受到改变。

在进行比较操作时，值类型的变量会直接比较他们的值，如果值相等，则返回true；引用类型的变量会比较他们的引用地址，虽然两个变量在堆中存储的对象具有相同的属性值，但他们被存在了不同的存储空间，比较值就会返回false。（如果适合是复制一个引用类型，则比较值为true）

在进行函数参数传递时，所有的函数的参数都是按照值传递的。当变量是值类型时，传的是指本身；当变量是引用类型时，传的是指向堆内存的地址。



#### 7.null和 undefined的区别

null和undefined·都表示空或无。其中

null表示被赋值过的对象，将它的值赋为null，一个对象某个属性的值为null是正常的，null转换为数值时值为0；

undefined表示未定义的值为undefined，如果说一个对象的某个属性值为undefined是错误的，undefined转为数值时值为NAN（非数字值的特殊值）。

#### 8.至少可以说出三种判断 JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型

- typeof

  使用typeof操作符可以准确判断一个变量是否为原始类型或函数类型，但不适用于引用类型，除函数外所有的引用类型都会被判定为object;

  另外还有一个JavaScript设计的bug，typeof  null === 'object'，一直没有被修复

- instanceof

  instanceof操作符可以帮助我们判断引用类型具体是什么类型的对象，原理上 `[] instanceof Array`实际是判断Array.prototype是否在[]的原型链上。所以使用instanceof来检测数据类型不会很准确，另外，它也不能检测基本数据类型

- toString

  





#### 9.可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用





#### 10.出现小数精度丢失的原因， JavaScript可以存储的最大数字、最大安全数字， JavaScript处理大数字的方法、避免精度丢失的方法

##### 1）小数精度丢失原因：

计算机中所有的数据都是以二进制存储的，在计算时计算机要先把十进制数据转为二进制进行计算，然后再把计算结果转为十进制。实际上是二进制计算发生了精度丢失。在ECMAScript语言规范中规定，Number类型遵循IEEE 754标准，使用64位固定长度来表示，JavaScript使用64位双精度浮点数编码，它的符号位占1位，指数位占11位，尾数位占52位。

`符号位`就是标识正负的，`1`表示`负`，`0`表示`正`；

`指数位`存储科学计数法的指数；

`尾数位`存储科学计数法后的有效数字；

所以我们通常看到的二进制，其实是计算机实际存储的尾数位。

由于尾数位只能存储52个数字，有效数字第`53`位及以后的数字是不能存储的，它遵循，如果是`1`就向前一位进`1`，如果是`0`就舍弃的原则，所以会产生精度丢失。

##### 2）最大数字：

由与`IEEE 754`双精度64位规范的限制：

`指数位`能表示的最大数字：`1023`(十进制)

`尾数位`能表达的最大数字即尾数位都位`1`的情况

所以JavaScript能表示的最大数字即位

`1.111...`X 2^1023 这个结果转换成十进制是`1.7976931348623157e+308`,这个结果即为`Number.MAX_VALUE`。

##### 3)最大安全数字

JavaScript中`Number.MAX_SAFE_INTEGER`表示最大安全数字,计算结果是`9007199254740991`，即在这个数范围内不会出现精度丢失（小数除外）,这个数实际上是`1.111...`X 2^52。

##### 4)处理大整数

可以使用一些开源库来解决，如node-bignum、node-bigint

##### 5)处理精度丢失

开源库：number-precision、mathjs